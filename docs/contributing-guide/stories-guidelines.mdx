import { Meta } from '@storybook/blocks';
import { PageOutline } from '../components/PageOutline';

<Meta title="Contributing Guide/Stories Guidelines"/>

# Stories Guidelines
We use [Storybook](https://storybook.js.org/) to create our documentation.
All components have their own stories, which are used to present how to use them. All of the important story-related topics are explained in [Storybook Docs](https://storybook.js.org/basics/writing-stories/).
This page has our guidelines for stories.

<PageOutline/>

## Basic
Stories should cover all of the possible use cases of a component.
* You should write stories for all modifiers e.g. [UiAlert](/docs/atoms-alert--default) should have a story for default, success, warning, and error.
* All slots should be covered. Stories for slots should be named `With <slot-name> Slot` i.e. `With Title Slot`.
Stories should use the default template from the component and bind all of the props from it.

```js
export const WithRemoveSlot = () => ({
  template: `<Component>
    <template #remove="{ clickHandler, attrs }">
      <UiButton
        v-bind="attrs"
        @click="clickHandler"
      >
        <UiIcon />
      </UiButton>
    </template>
  </Component>`
})
```


## Name Conflict
In some cases, we have to use the same name for slots and props. In these cases, Storybook will return only one of them.
Slots probably have priority over props. To solve this issue, we can use 'argTypes' and add a prop and slot manually. e.g.

```js
argTypes: {
  // for props, we use a key with its name
  title: {
    table: {
      type: { summary: 'string' },
      category: 'props',
    },
    control: 'text',
  },
  // for slots, we use a key with the 'Slot' suffix
  titleSlot: {
    name: 'title', // and rename it to name without suffix
    description: 'Use this slot to replace title template.',
    table: {
      type: { summary: 'unknown' },
      category: 'slots',
    },
  },
}
```

## Helpers
To avoid writing the same code for the same thing, we use helpers. At the moment, we handle a few argTypes but will probably be adding more helpers in the near future.

```js
import { modifiers } from '@sb/helpers/argTypes';

export default {
  argTypes: {
    modifiers: modifiers({options: ['component--primary', 'component--sections', ...]}),
  }
}
```
Helpers are stored in the `.storybook/helpers/argTypes` folder.

## Custom DocsBlock
Storybook supports adding custom documentation components to a story. These components are created in React and stored in the `doc/component` folder.
These components are used for mdx files like those used to create the guidelines.

### Page Outline
THis is an auto-generated page outline from the headings in the page.
```js
import { PageOutline } from '../components/PageOutline';

<PageOutline/>
```

### Alert
Allows you to add a message in highlighted form. Alert has a border and a background color. It can be used to show important information.

```js
import { Alert } from '../components/Alert';

<Alert theme="[info|success|warning|error]">
  <p>Alert content.</p>
</Alert>
```

## Table Categories
By default, in the documentation you'll find 'PROPS', 'SLOTS', and 'EVENTS'. But in the Symptom-Checker UI Kit, we also have a few custom categories.
* STORIES CONTROLS - This category is used to group up those controls that are used in stories to mock up some data e.g. content, items, etc.
* HTML ATTRIBUTES - This category is used to group up the controls that are used as HTML attributes  e.g class or disabled

### Order of categories
* STORIES CONTROLS
* HTML ATTRIBUTES
* PROPS
* EVENTS
* SLOTS

## Events
Some components can emit events. We can use the `Actions` add-on to log these events and describe them in argTypes. e.g.

```js
import { actions } from '@storybook/addon-actions';

const events = actions({
  onFieldFocus: 'field-focus',
  onUpdateInvalid: 'update:invalid'
  onUpdateModelValue: 'update:modelValue',
}

export default {
  ...,
  argTypes: {
    'field-focus': {
      description: 'Use this event to detect when some field is focused.',
        table: {
        category: 'events',
      },
    },
  }
}

export const Component = (args) => ({
  setup() {
    return {
      ...args,
      ...events,
    }
  },
  template: `<Component
    @field-focus="onFieldFocus"
    @update:invalid="onUpdateInvalid"
  />`
})
```

To track emitted events, you can go to `Canvas -> Actions` and click the elements of a story.

## Model Value
Storybook in Docs mode passes args in a custom way and disallows you from passing props from Vue `setup() {}`.
It blocks the use of `v-model` in stories while in Docs mode. However, in Canvas mode, this works fine.
To solve this issue, we use args with the `init` prefix i.e. `initModelValue`, `initInvalid`.


```js
export default {
  ...,
  args: {
    initModelValue: '2077-11-27',
  },
  argTypes: {
    initModelValue: {
      description: 'Use this control to set initial state.',
      table: {
        category: 'stories controls',
      },
      control: 'text',
    },
  }
}
```

## Content
Some components can pass content e.g. the label of a button, array with values for checkboxes, etc.
These are added to the STORIES CONTROLS and allow you to change the content of the component/ group of components. e.g.

```js
export default {
  args: {
    values: [
      {},
      {},
      ...
  ],
  },
  argTypes: {
    values: {
      description: 'Use this control to set the values of checkbox group.',
      table: {
        category: 'stories controls',
      },
      control: 'array',
    },
  }
}
```
## CSS in stories
### Tailwind CSS
We use [Tailwind CSS](https://tailwindcss.com/) in our stories. Tailwind helps us to write less CSS and focus on the content of a story. We use it in decorators. We do not use it to add styles to Component Library components.

### Custom CSS
Sometimes we need to add custom CSS to a story. To do this, we add a `<component-name>.stories.scss` file in the component directory and import it in `*.stories.js` e.g.

```js
// *.stories.js
import './*.stories.scss';

export default {
  title: '',
  component: '',
  ...
}
```
We mostly want to display this custom CSS (scss to be more precise) in the documentation. To do that, we need to use a `*.mdx` file and import it in `*.stories.js`. To use this in `*.stories.js`, we need to set the `docs` parameters e.g.

```js
// *.stories.js
import './*.stories.scss';

export default {
  title: '',
  component: '',
}
```
To display SCSS in a `mdx` file, we use the `<Code/>` DocBlock component e.g.

```mdx
import { Code } from '../../../../docs/components/Code';
import * as stories from './ComponentName.stories.js';

<Meta of={stories}/>

## ComponentName
<Canvas of={stories.Common}/>
<Controls of={stories.Common} />

## Stories
### With custom CSS
<Canvas of={stories.WithCustomCss}/>

**Use the following SCSS to get the same result**
<Code
  id="with-custom-css"
  code={ scss }
/>
```

And wrap the code in `Code` tags to display it in a `<Code>` block e.g.

```scss
//<Code id="with-custom-css">
.with-custom-css {
 // your custom CSS
}
//</Code>
```


