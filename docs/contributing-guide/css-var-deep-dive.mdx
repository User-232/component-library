import { Meta } from '@storybook/blocks';
import { PageOutline } from '../components/PageOutline';
import { Code } from '../components/Code';

<Meta title="Contributing Guide/CSS Var Deep Dive"/>

# CSS Var Deep Dive
CSS Custom Properties (or CSS variables) are a powerful solution but they do have a few issues.

<PageOutline/>

## How to name CSS variables
To name CSS variables, we recommend BEM. `--<block>-<element>-<modifier>` e.g.

<Code code={`.ui-button {
  color: var(--button-color, var(--color-text-on-action))\n
  &__icon {
    --icon-size: var(--tile-icon-size, 3rem);\n
  }
}`}/>

### Breakpoints
Our component library is mobile first in terms of styles. However, in certain cases, changing some properties for `tablet` or `desktop` devices is recommended. e.g.

<Code code={`.ui-tile {
  &__icon {
    --icon-size: var(--tile-icon-size, 3rem);\n
    @include mixins.from-tablet {
      --icon-size: var(--tile-tablet-icon-size, 4rem);
    }
  }
}`}/>

As you can see in the example above, we added `-tablet` to the variable name. `-<breakpoint-name>` will be only added to the block.

### hover and active

Components like buttons use the `:hover` and `:active` pseudo classes. e.g.

<Code code={`.ui-button {
  background: var(--button-background, var(--color-background-action));\n
  @media (hover: hover) {
    &:hover {
      background: var(--button-hover-background, var(--color-background-action-hover));
    }
  }\n
  &:active {
    background: var(--button-active-background, var(--color-background-action-active));
  }
}`}/>

As you can see in the examples above, we added `-hover` and `-active` to the variable names. The state will be added to the element that triggers it.

<Code code={`.ui-button {
  $this: &;\n
  @media (hover: hover) {
    &:hover {
      #{$this}__icon {
        --icon-color: var(--button-hover-icon-color, var(--color-icon-on-action-hover))
      }
    }
  }\n
  &:active {
    #{$this}__icon {
        --icon-color: var(--button-hover-icon-color, var(--color-icon-on-action-active))
    }
  }\n
  &__icon {
    --icon-color: var(--button-hover-icon-color, var(--color-icon-on-action))
  }
}`}/>

As you can see in the example, we added `-hover` and `-active` after the block called `button` because the button is the trigger for the hover and active states.

### Checked

Components like UiRadio, UiCheckbox, and UiTile have the `-checked` modifier in the variable name e.g.

<Code code={`.ui-checkbox {
  &__checkbox {
    background: var(--checkbox-background, var(--color-background-white));\n
    &--is-checked {
      background: var(--checkbox-checked-background, var(--color-selectioncontrols-selection));
    }
  }
}`}/>

## Why do we use a lot of name modifiers?
When you set a custom value for a variable, you need to create a new css class or use an existing one like `.ui-button`. e.g.

<Code code={`.my-awesome-button {
  --button-background: var(--color-background-action);\n
  &:hover {
    --button-background: var(--color-background-action-hover);
  }\n
  &:active {
    --button-background: var(--color-background-action-active);
  }
}`}/>

But, as you can see in the example above, this creates a lot of unnecessary lines of code. Our approach greatly simplifies this process.

<Code code={`.my-awesome-button {
  --button-background: var(--color-background-action);
  --button-hover-background: var(--color-background-action-hover);
  --button-active-background: var(--color-background-action-active);
}`}/>

That said, we can't handle every use case. When a component does not provide the variable you need, you can set it yourself by using the approach from the top of this paragraph.

## With the correct property in components, styles should provide variables.

Initially, we tried to add CSS variables for all of the properties that developers wanted to override in their projects. e.g.

<Code code={`.ui-button {
  display: var(--button-display, inline-flex);
  width: var(--button-width);
  height: var(--button-height);
  align-items: var(--button-align-items, center);
  justify-content: var(--button-justify-content, center);
  padding: var(--button-padding, var(--space-12) var(--space-32));
  background: var(--button-background, var(--color-background-action));
  color: var(--button-color, var(--color-text-on-action));
}`}/>

That said, we can't predict all of the CSS variables that developers want to use. We'll have undefined variables anyway.
That's why we've decided to use variables only for the visual properties like colors, backgrounds, borders (width, radius) and spacers. e.g.

<Code code={`.ui-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: functions.var($element, padding, var(--space-12) var(--space-32));
  background: functions.var($element, background, var(--color-background-action));
  color: functions.var($element, color, var(--color-text-on-action));
}`}/>

If you want to set another property, you can do so.

## Why do we override properties instead of using variables?
The answer is Specificity and Cascading. When we use variables for e.g hover or modifiers, we can't override them in other places. The major reason for this is Cascading.

<Code code={`.ui-button {
  background: var(--button-background, var(--color-background-action));\n
  &--outlined {
    --button-background: transparent;
  }
}`}/>

And we try to override `--button-background` for element with `--outlined` modifier.

<Code code={`.ui-alert {
  &__cta {
    --button-background: var(--color-triage-emergency-ambulance);
  }
}`}/>

Specificity is the same but it will only work when `.ui-alert` styles are loaded after `.ui-button`. We can't 100% ensure that.
We build solutions that are resistant to this by overriding properties in components instead.

<Code code={`.ui-button {
  background: var(--button-background, var(--color-background-action));\n
  &--outlined {
    background: var(--button-background, transparent);\n
    @include mixins.hover {
      background: var(--button-element-hover-background, var(--color-background-white-hover))
    }
  }
}`}/>

